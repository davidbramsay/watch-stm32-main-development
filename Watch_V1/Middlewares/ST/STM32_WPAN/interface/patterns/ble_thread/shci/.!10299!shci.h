/**
 ******************************************************************************
 * @file    shci.h
 * @author  MCD Application Team
 * @brief   HCI command for the system channel
 ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics. 
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the 
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
 */


/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __SHCI_H
#define __SHCI_H

#ifdef __cplusplus
extern "C" {
#endif

  /* Includes ------------------------------------------------------------------*/
#include "mbox_def.h" /* Requested to expose the MB_WirelessFwInfoTable_t structure */

  /* Exported types ------------------------------------------------------------*/

  /* SYSTEM EVENT */
  typedef enum
  {
    WIRELESS_FW_RUNNING = 0x00,
    FUS_FW_RUNNING = 0x01,
  } SHCI_SysEvt_Ready_Rsp_t;

  /* ERROR CODES
   *
   * These error codes are detected on CPU2 side and are send back to the CPU1 via a system
   * notification message. It is up to the application running on CPU1 to manage these errors
   *
   * These errors can be generated by all layers (low level driver, stack, framework infrastructure, etc..)
   */
   typedef enum
   {
     ERR_BLE_INIT = 0,                 /* This event is currently not reported by the CPU2                    */
     ERR_THREAD_LLD_FATAL_ERROR = 125, /* The LLD driver used on 802_15_4 detected a fatal error              */
     ERR_THREAD_UNKNOWN_CMD = 126,     /* The command send by the CPU1 to control the Thread stack is unknown */
     ERR_ZIGBEE_UNKNOWN_CMD = 200,     /* The command send by the CPU1 to control the Zigbee stack is unknown */
   } SCHI_SystemErrCode_t;

#define SHCI_EVTCODE                    ( 0xFF )
#define SHCI_SUB_EVT_CODE_BASE          ( 0x9200 )

  /**
   * THE ORDER SHALL NOT BE CHANGED TO GUARANTEE COMPATIBILITY WITH THE CPU1 DEFINITION
   */
  typedef enum
  {
    SHCI_SUB_EVT_CODE_READY =  SHCI_SUB_EVT_CODE_BASE,
    SHCI_SUB_EVT_ERROR_NOTIF,
    SHCI_SUB_EVT_BLE_NVM_RAM_UPDATE,
    SHCI_SUB_EVT_THREAD_NVM_RAM_UPDATE,
    SHCI_SUB_EVT_NVM_START_WRITE,
    SHCI_SUB_EVT_NVM_END_WRITE,
    SHCI_SUB_EVT_NVM_START_ERASE,
    SHCI_SUB_EVT_NVM_END_ERASE,
    SHCI_SUB_EVT_CODE_CONCURRENT_802154_EVT,
  } SHCI_SUB_EVT_CODE_t;

  /**
   * SHCI_SUB_EVT_CODE_READY
   * This notifies the CPU1 that the CPU2 is now ready to receive commands
   * It reports as well which firmware is running on CPU2 : The wireless stack of the FUS (previously named RSS)
   */
  typedef PACKED_STRUCT{
    SHCI_SysEvt_Ready_Rsp_t sysevt_ready_rsp;
  } SHCI_C2_Ready_Evt_t;

  /**
   * SHCI_SUB_EVT_ERROR_NOTIF
   * This reports to the CPU1 some error form the CPU2
   */
  typedef PACKED_STRUCT{
    SCHI_SystemErrCode_t errorCode;
  } SHCI_C2_ErrorNotif_Evt_t;

  /**
   * SHCI_SUB_EVT_BLE_NVM_RAM_UPDATE
   * This notifies the CPU1 which part of the BLE NVM RAM has been updated so that only the modified
   * section could be written in Flash/NVM
   * StartAddress : Start address of the section that has been modified
   * Size : Size (in bytes) of the section that has been modified
   */
  typedef PACKED_STRUCT{
    uint32_t StartAddress;
    uint32_t Size;
  } SHCI_C2_BleNvmRamUpdate_Evt_t;

  /**
   * SHCI_SUB_EVT_THREAD_NVM_RAM_UPDATE
   * This notifies the CPU1 which part of the OT NVM RAM has been updated so that only the modified
   * section could be written in Flash/NVM
   * StartAddress : Start address of the section that has been modified
   * Size : Size (in bytes) of the section that has been modified
   */
  typedef PACKED_STRUCT{
    uint32_t StartAddress;
    uint32_t Size;
  } SHCI_C2_ThreadNvmRamUpdate_Evt_t;

  /**
   * SHCI_SUB_EVT_NVM_START_WRITE
   * This notifies the CPU1 that the CPU2 has started a write procedure in Flash
   * NumberOfWords : The number of 64bits data the CPU2 needs to write in Flash.
   *                 For each 64bits data, the algorithm as described in AN5289 is executed.
   *                 When this number is reported to 0, it means the Number of 64bits to be written
   *                 was unknown when the procedure has started.
   * When all data are written, the SHCI_SUB_EVT_NVM_END_WRITE event is reported
   */
  typedef PACKED_STRUCT{
    uint32_t NumberOfWords;
  } SHCI_C2_NvmStartWrite_Evt_t;

  /**
   * SHCI_SUB_EVT_NVM_END_WRITE
   * This notifies the CPU1 that the CPU2 has written all expected data in Flash
   */

  /**
   * SHCI_SUB_EVT_NVM_START_ERASE
   * This notifies the CPU1 that the CPU2 has started a erase procedure in Flash
   * NumberOfSectors : The number of sectors the CPU2 needs to erase in Flash.
   *                   For each sector, the algorithm as described in AN5289 is executed.
   *                   When this number is reported to 0, it means the Number of sectors to be erased
   *                   was unknown when the procedure has started.
   * When all sectors are erased, the SHCI_SUB_EVT_NVM_END_ERASE event is reported
   */
  typedef PACKED_STRUCT{
    uint32_t NumberOfSectors;
  } SHCI_C2_NvmStartErase_Evt_t;

  /**
   * SHCI_SUB_EVT_NVM_END_ERASE
   * This notifies the CPU1 that the CPU2 has erased all expected flash sectors
   */

  /* SYSTEM COMMAND */
  typedef PACKED_STRUCT
  {
    uint32_t MetaData[3];
  } SHCI_Header_t;

  typedef enum
  {
    SHCI_Success = 0x00,
    SHCI_UNKNOWN_CMD = 0x01,
    SHCI_ERR_UNSUPPORTED_FEATURE = 0x11,
    SHCI_ERR_INVALID_HCI_CMD_PARAMS = 0x12,
    SHCI_ERR_INVALID_PARAMS = 0x42,
    SHCI_FUS_CMD_NOT_SUPPORTED = 0xFF,
  } SHCI_CmdStatus_t;

  typedef enum
  {
    SHCI_8BITS =  0x01,
    SHCI_16BITS = 0x02,
    SHCI_32BITS = 0x04,
  } SHCI_Busw_t;

#define SHCI_OGF                        ( 0x3F )
#define SHCI_OCF_BASE                   ( 0x50 )

  /**
   * THE ORDER SHALL NOT BE CHANGED TO GUARANTEE COMPATIBILITY WITH THE CPU2 DEFINITION
   */
  typedef enum
  {
    SHCI_OCF_C2_RESERVED1 =  SHCI_OCF_BASE,
    SHCI_OCF_C2_RESERVED2,
    SHCI_OCF_C2_FUS_GET_STATE,
    SHCI_OCF_C2_FUS_RESERVED1,
    SHCI_OCF_C2_FUS_FW_UPGRADE,
    SHCI_OCF_C2_FUS_FW_DELETE,
    SHCI_OCF_C2_FUS_UPDATE_AUTH_KEY,
    SHCI_OCF_C2_FUS_LOCK_AUTH_KEY,
    SHCI_OCF_C2_FUS_STORE_USR_KEY,
    SHCI_OCF_C2_FUS_LOAD_USR_KEY,
    SHCI_OCF_C2_FUS_START_WS,
    SHCI_OCF_C2_FUS_RESERVED2,
    SHCI_OCF_C2_FUS_RESERVED3,
    SHCI_OCF_C2_FUS_LOCK_USR_KEY,
    SHCI_OCF_C2_FUS_RESERVED5,
    SHCI_OCF_C2_FUS_RESERVED6,
    SHCI_OCF_C2_FUS_RESERVED7,
    SHCI_OCF_C2_FUS_RESERVED8,
    SHCI_OCF_C2_FUS_RESERVED9,
    SHCI_OCF_C2_FUS_RESERVED10,
    SHCI_OCF_C2_FUS_RESERVED11,
    SHCI_OCF_C2_FUS_RESERVED12,
    SHCI_OCF_C2_BLE_INIT,
    SHCI_OCF_C2_THREAD_INIT,
    SHCI_OCF_C2_DEBUG_INIT,
    SHCI_OCF_C2_FLASH_ERASE_ACTIVITY,
    SHCI_OCF_C2_CONCURRENT_SET_MODE,
    SHCI_OCF_C2_FLASH_STORE_DATA,
    SHCI_OCF_C2_FLASH_ERASE_DATA,
    SHCI_OCF_C2_RADIO_ALLOW_LOW_POWER,
    SHCI_OCF_C2_MAC_802_15_4_INIT,
    SHCI_OCF_C2_REINIT,
    SHCI_OCF_C2_ZIGBEE_INIT,
    SHCI_OCF_C2_LLD_TESTS_INIT,
    SHCI_OCF_C2_EXTPA_CONFIG,
    SHCI_OCF_C2_SET_FLASH_ACTIVITY_CONTROL,
    SHCI_OCF_C2_LLD_BLE_INIT,
    SHCI_OCF_C2_CONFIG,
    SHCI_OCF_C2_CONCURRENT_GET_NEXT_BLE_EVT_TIME,
    SHCI_OCF_C2_CONCURRENT_ENABLE_NEXT_802154_EVT_NOTIFICATION,
  } SHCI_OCF_t;

#define SHCI_OPCODE_C2_FUS_GET_STATE         (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_GET_STATE)
/** No command parameters */
/** Response parameters*/
/** It responds a 1 byte value holding FUS State error code when the FUS State value is 0xFF (FUS_STATE_VALUE_ERROR) */
  typedef enum
  {
    FUS_STATE_ERROR_NO_ERROR =  0x00,
    FUS_STATE_ERROR_IMG_NOT_FOUND = 0x01,
    FUS_STATE_ERROR_IMG_CORRUPT = 0x02,
    FUS_STATE_ERROR_IMG_NOT_AUTHENTIC = 0x03,
    FUS_STATE_ERROR_IMG_NOT_ENOUGH_SPACE = 0x04,
    FUS_STATE_ERROR_IMAGE_USRABORT = 0x05,
    FUS_STATE_ERROR_IMAGE_ERSERROR = 0x06,
    FUS_STATE_ERROR_IMAGE_WRTERROR = 0x07,
    FUS_STATE_ERROR_AUTH_TAG_ST_NOTFOUND = 0x08,
    FUS_STATE_ERROR_AUTH_TAG_CUST_NOTFOUND = 0x09,
    FUS_STATE_ERROR_AUTH_KEY_LOCKED = 0x0A,
    FUS_STATE_ERROR_FW_ROLLBACK_ERROR = 0x11,
    FUS_STATE_ERROR_STATE_NOT_RUNNING = 0xFE,
    FUS_STATE_ERROR_ERR_UNKNOWN = 0xFF,
  } SHCI_FUS_GetState_ErrorCode_t;

  enum
  {
    FUS_STATE_VALUE_IDLE =  0x00,
    FUS_STATE_VALUE_FW_UPGRD_ONGOING =  0x10,
    FUS_STATE_VALUE_FW_UPGRD_ONGOING_END = 0x1F,    /* All values between 0x10 and 0x1F has the same meaning */
    FUS_STATE_VALUE_FUS_UPGRD_ONGOING =  0x20,
    FUS_STATE_VALUE_FUS_UPGRD_ONGOING_END =  0x2F,  /* All values between 0x20 and 0x2F has the same meaning */
    FUS_STATE_VALUE_SERVICE_ONGOING =  0x30,
    FUS_STATE_VALUE_SERVICE_ONGOING_END =  0x3F,    /* All values between 0x30 and 0x3F has the same meaning */
    FUS_STATE_VALUE_ERROR =  0xFF,
  };

#define SHCI_OPCODE_C2_FUS_RESERVED1         (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_RESERVED1)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_FUS_FW_UPGRADE   (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_FW_UPGRADE)
  /** No structure for command parameters */
  /** No response parameters*/

#define SHCI_OPCODE_C2_FUS_FW_DELETE   (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_FW_DELETE)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_FUS_UPDATE_AUTH_KEY    (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_UPDATE_AUTH_KEY)
  typedef PACKED_STRUCT{
  uint8_t KeySize;
  uint8_t KeyData[64];
  } SHCI_C2_FUS_UpdateAuthKey_Cmd_Param_t;

  /** No response parameters*/

#define SHCI_OPCODE_C2_FUS_LOCK_AUTH_KEY    (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_LOCK_AUTH_KEY)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_FUS_STORE_USR_KEY    (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_STORE_USR_KEY)
  /** Command parameters */
  /* List of supported key type */
  enum
  {
    KEYTYPE_NONE =  0x00,
    KEYTYPE_SIMPLE = 0x01,
    KEYTYPE_MASTER = 0x02,
    KEYTYPE_ENCRYPTED = 0x03,
  };

  /* List of supported key size */
  enum
  {
    KEYSIZE_16 =  16,
    KEYSIZE_32 = 32,
  };

  typedef PACKED_STRUCT{
  uint8_t KeyType;
  uint8_t KeySize;
  uint8_t KeyData[32 + 12];
  } SHCI_C2_FUS_StoreUsrKey_Cmd_Param_t;

  /** Response parameters*/
  /** It responds a 1 byte value holding the index given for the stored key */

#define SHCI_OPCODE_C2_FUS_LOAD_USR_KEY         (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_LOAD_USR_KEY)
  /** Command parameters */
  /** 1 byte holding the key index value */

  /** No response parameters*/

#define SHCI_OPCODE_C2_FUS_START_WS             (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_START_WS)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_FUS_RESERVED2            (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_RESERVED2)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_FUS_RESERVED3            (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_RESERVED3)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_FUS_LOCK_USR_KEY         (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_LOCK_USR_KEY)
  /** Command parameters */
  /** 1 byte holding the key index value */

  /** No response parameters*/

#define SHCI_OPCODE_C2_FUS_RESERVED5            (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_RESERVED5)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_FUS_RESERVED6            (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_RESERVED6)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_FUS_RESERVED7            (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_RESERVED7)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_FUS_RESERVED8            (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_RESERVED8)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_FUS_RESERVED9            (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_RESERVED9)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_FUS_RESERVED10           (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_RESERVED10)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_FUS_RESERVED11           (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_RESERVED11)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_FUS_RESERVED12           (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_RESERVED12)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_BLE_INIT                 (( SHCI_OGF << 10) + SHCI_OCF_C2_BLE_INIT)
  /** THE ORDER SHALL NOT BE CHANGED    */
  typedef PACKED_STRUCT{
  uint8_t* pBleBufferAddress;   /**< NOT USED - shall be set to 0 */
  uint32_t BleBufferSize;       /**< NOT USED - shall be set to 0 */

  /**
   * NumAttrRecord
   * Maximum number of attribute records related to all the required characteristics (excluding the services)
   * that can be stored in the GATT database, for the specific BLE user application.
   * For each characteristic, the number of attribute records goes from two to five depending on the characteristic properties:
   *    - minimum of two (one for declaration and one for the value)
   *    - add one more record for each additional property: notify or indicate, broadcast, extended property.
   * The total calculated value must be increased by 9, due to the records related to the standard attribute profile and
   * GAP service characteristics, and automatically added when initializing GATT and GAP layers
   *  - Min value: <number of user attributes> + 9
   *  - Max value: depending on the GATT database defined by user application
   */
  uint16_t NumAttrRecord;

  /**
   * NumAttrServ
   * Defines the maximum number of services that can be stored in the GATT database. Note that the GAP and GATT services
   * are automatically added at initialization so this parameter must be the number of user services increased by two.
   *    - Min value: <number of user service> + 2
   *    - Max value: depending GATT database defined by user application
   */
  uint16_t NumAttrServ;

  /**
   * AttrValueArrSize
   * NOTE: This parameter is ignored by the CPU2 when the parameter "Options" is set to "LL_only" ( see Options description in that structure )
   *
   * Size of the storage area for the attribute values.
   * Each characteristic contributes to the attrValueArrSize value as follows:
   *    - Characteristic value length plus:
   *        + 5 bytes if characteristic UUID is 16 bits
   *        + 19 bytes if characteristic UUID is 128 bits
   *        + 2 bytes if characteristic has a server configuration descriptor
   *        + 2 bytes * NumOfLinks if the characteristic has a client configuration descriptor
   *        + 2 bytes if the characteristic has extended properties
   * Each descriptor contributes to the attrValueArrSize value as follows:
   *    - Descriptor length
   */
  uint16_t AttrValueArrSize;

  /**
   * NumOfLinks
   * Maximum number of BLE links supported
   *    - Min value: 1
   *    - Max value: 8
   */
  uint8_t NumOfLinks;

  /**
   * ExtendedPacketLengthEnable
   * Disable/enable the extended packet length BLE 5.0 feature
   *    - Disable: 0
   *    - Enable: 1
   */
  uint8_t ExtendedPacketLengthEnable;

  /**
   * PrWriteListSize
   * NOTE: This parameter is ignored by the CPU2 when the parameter "Options" is set to "LL_only" ( see Options description in that structure )
   *
